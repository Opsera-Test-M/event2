# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸš€ Bootstrap Infrastructure - Plan & Joy
# One-time setup for ArgoCD, ECR, and spoke cluster registration
# Generated by Opsera Code-to-Cloud v4.0
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
name: "ğŸš€ Bootstrap - plan-and-joy"

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'dev'
        type: string
      region:
        description: 'AWS Region'
        required: true
        default: 'us-west-2'
        type: string

env:
  APP_NAME: plan-and-joy
  TENANT: opsera
  AWS_REGION: ${{ github.event.inputs.region || 'us-west-2' }}
  ENVIRONMENT: ${{ github.event.inputs.environment || 'dev' }}
  DOMAIN: agent.opsera.dev
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Hub-Spoke Architecture (SKILL-HUB-SPOKE-001)
  # HUB_CLUSTER: Where ArgoCD runs (management plane)
  # SPOKE_CLUSTER: Where applications run (workload plane)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  HUB_CLUSTER: argocd-usw2
  SPOKE_CLUSTER: opsera-usw2-np

concurrency:
  group: bootstrap-${{ github.event.inputs.environment || 'dev' }}
  cancel-in-progress: false

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Job 1: Verify Prerequisites
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  verify-prerequisites:
    name: "ğŸ” Verify Prerequisites"
    runs-on: ubuntu-latest
    outputs:
      subdomain: ${{ steps.subdomain.outputs.value }}
      ecr_uri: ${{ steps.ecr.outputs.uri }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get AWS Account ID
        id: account
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "id=$AWS_ACCOUNT_ID" >> $GITHUB_OUTPUT
          echo "âœ… AWS Account ID: $AWS_ACCOUNT_ID"

      - name: Generate Subdomain
        id: subdomain
        run: |
          SUBDOMAIN="${{ env.TENANT }}-${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}.${{ env.DOMAIN }}"
          echo "value=$SUBDOMAIN" >> $GITHUB_OUTPUT
          echo "âœ… Subdomain: $SUBDOMAIN"

      - name: Create ECR Repository (if not exists)
        id: ecr
        run: |
          AWS_ACCOUNT_ID="${{ steps.account.outputs.id }}"
          ECR_REPO="${{ env.TENANT }}/${{ env.APP_NAME }}"
          ECR_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"

          if aws ecr describe-repositories --repository-names "$ECR_REPO" 2>/dev/null; then
            echo "âœ… ECR repository exists: $ECR_REPO"
          else
            echo "ğŸ“ Creating ECR repository: $ECR_REPO"
            aws ecr create-repository \
              --repository-name "$ECR_REPO" \
              --image-scanning-configuration scanOnPush=true \
              --tags Key=Tenant,Value=${{ env.TENANT }} Key=App,Value=${{ env.APP_NAME }}
            echo "âœ… ECR repository created"
          fi

          echo "uri=$ECR_URI" >> $GITHUB_OUTPUT

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Job 2: Update Manifests
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  update-manifests:
    name: "ğŸ“ Update Manifests"
    runs-on: ubuntu-latest
    needs: verify-prerequisites
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}
          fetch-depth: 0

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Get Repository URL
        id: repo
        run: |
          REPO_URL=$(git remote get-url origin)
          echo "url=$REPO_URL" >> $GITHUB_OUTPUT
          echo "âœ… Repository URL: $REPO_URL"

      - name: Update ArgoCD Application
        run: |
          APP_MANIFEST=".opsera-${{ env.APP_NAME }}/argocd/application.yaml"

          # Update repository URL
          sed -i "s|PLACEHOLDER_REPO_URL|${{ steps.repo.outputs.url }}|g" "$APP_MANIFEST"

          # Update application name for environment
          sed -i "s|name: ${{ env.APP_NAME }}-.*|name: ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}|" "$APP_MANIFEST"
          sed -i "s|environment: .*|environment: ${{ env.ENVIRONMENT }}|" "$APP_MANIFEST"
          sed -i "s|path: .opsera-${{ env.APP_NAME }}/k8s/overlays/.*|path: .opsera-${{ env.APP_NAME }}/k8s/overlays/${{ env.ENVIRONMENT }}|" "$APP_MANIFEST"
          sed -i "s|namespace: ${{ env.APP_NAME }}-.*|namespace: ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}|" "$APP_MANIFEST"

          echo "âœ… Updated ArgoCD application manifest"
          cat "$APP_MANIFEST"

      - name: Update Ingress Subdomain
        run: |
          SUBDOMAIN="${{ needs.verify-prerequisites.outputs.subdomain }}"

          # Update base ingress
          sed -i "s|PLACEHOLDER_SUBDOMAIN|$SUBDOMAIN|g" \
            .opsera-${{ env.APP_NAME }}/k8s/base/ingress.yaml

          # Update overlay ingress
          sed -i "s|PLACEHOLDER_SUBDOMAIN|$SUBDOMAIN|g" \
            .opsera-${{ env.APP_NAME }}/k8s/overlays/${{ env.ENVIRONMENT }}/patch-ingress.yaml

          echo "âœ… Updated ingress subdomain to: $SUBDOMAIN"

      - name: Update ECR URI
        run: |
          ECR_URI="${{ needs.verify-prerequisites.outputs.ecr_uri }}/${{ env.TENANT }}/${{ env.APP_NAME }}"

          # Update base kustomization
          sed -i "s|PLACEHOLDER_ECR_URI/${{ env.APP_NAME }}|$ECR_URI|g" \
            .opsera-${{ env.APP_NAME }}/k8s/base/kustomization.yaml

          # Update overlay kustomization
          sed -i "s|PLACEHOLDER_ECR_URI/${{ env.APP_NAME }}|$ECR_URI|g" \
            .opsera-${{ env.APP_NAME }}/k8s/overlays/${{ env.ENVIRONMENT }}/kustomization.yaml

          echo "âœ… Updated ECR URI to: $ECR_URI"

      - name: Pull Latest Changes
        run: git pull --rebase origin main || true

      - name: Commit and Push Changes
        run: |
          git add .opsera-${{ env.APP_NAME }}/
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "chore: bootstrap ${{ env.APP_NAME }} for ${{ env.ENVIRONMENT }} [skip ci]"
            git push origin main
            echo "âœ… Changes committed and pushed"
          fi

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Job 3: Setup ArgoCD
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  setup-argocd:
    name: "ğŸ”„ Setup ArgoCD"
    runs-on: ubuntu-latest
    needs: [verify-prerequisites, update-manifests]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: main
          token: ${{ secrets.GH_PAT }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Connect to Hub Cluster
        run: |
          aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }}
          kubectl cluster-info

      - name: Verify Spoke Cluster Registration
        run: |
          echo "ğŸ” Verifying spoke cluster is registered with ArgoCD..."
          
          if kubectl get secret -n argocd -l argocd.argoproj.io/secret-type=cluster | grep -q "${{ env.SPOKE_CLUSTER }}"; then
            echo "âœ… Spoke cluster '${{ env.SPOKE_CLUSTER }}' is registered with ArgoCD"
          else
            echo "âš ï¸ Warning: Spoke cluster secret not found by name"
            echo "Available cluster secrets:"
            kubectl get secrets -n argocd -l argocd.argoproj.io/secret-type=cluster \
              -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}'
            echo ""
            echo "Proceeding - cluster may be registered under different identifier"
          fi

      - name: Create ArgoCD Repository Secret
        run: |
          REPO_URL=$(git remote get-url origin)

          if kubectl get secret repo-${{ env.APP_NAME }} -n argocd 2>/dev/null; then
            echo "âœ… Repository secret exists"
          else
            kubectl create secret generic repo-${{ env.APP_NAME }} \
              --namespace argocd \
              --from-literal=url="$REPO_URL" \
              --from-literal=password="${{ secrets.GH_PAT }}" \
              --from-literal=username="git" \
              --from-literal=type=git
            kubectl label secret repo-${{ env.APP_NAME }} -n argocd \
              argocd.argoproj.io/secret-type=repository
            echo "âœ… Repository secret created"
          fi

      - name: Pull Latest Manifests
        run: git pull --rebase origin main || true

      - name: Apply ArgoCD Application
        run: |
          kubectl apply -f .opsera-${{ env.APP_NAME }}/argocd/application.yaml
          echo "âœ… ArgoCD application applied"

      - name: Verify ArgoCD Application Sync
        run: |
          echo "â³ Waiting for ArgoCD to process application..."
          sleep 15
          
          MAX_ATTEMPTS=20
          for i in $(seq 1 $MAX_ATTEMPTS); do
            STATUS=$(kubectl get app ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} -n argocd \
              -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Pending")
            HEALTH=$(kubectl get app ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} -n argocd \
              -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Pending")
            
            echo "[$i/$MAX_ATTEMPTS] Sync: $STATUS | Health: $HEALTH"
            
            if [ "$STATUS" = "Unknown" ]; then
              echo ""
              echo "âš ï¸ Warning: Sync status 'Unknown' - possible cluster connectivity issue"
              echo "Run 'refresh-argocd-cluster.yaml' workflow if this persists"
            fi
            
            if [ "$STATUS" = "Synced" ]; then
              echo "âœ… ArgoCD application synced successfully"
              break
            fi
            
            sleep 10
          done
          
          kubectl get application ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} -n argocd -o wide
          echo "âœ… ArgoCD application verification complete"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Job 4: Summary
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  summary:
    name: "ğŸ“‹ Bootstrap Summary"
    runs-on: ubuntu-latest
    needs: [verify-prerequisites, update-manifests, setup-argocd]
    if: always()
    steps:
      - name: Display Summary
        run: |
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘  ğŸ‰ BOOTSTRAP COMPLETE - Plan & Joy                                          â•‘"
          echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
          echo "â•‘  App:         ${{ env.APP_NAME }}"
          echo "â•‘  Environment: ${{ env.ENVIRONMENT }}"
          echo "â•‘  Region:      ${{ env.AWS_REGION }}"
          echo "â•‘  Subdomain:   ${{ needs.verify-prerequisites.outputs.subdomain }}"
          echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
          echo "â•‘  NEXT STEPS:                                                                 â•‘"
          echo "â•‘  1. Run the CI/CD workflow to build and deploy                               â•‘"
          echo "â•‘     gh workflow run ci-cd-plan-and-joy.yaml -f environment=${{ env.ENVIRONMENT }}"
          echo "â•‘                                                                              â•‘"
          echo "â•‘  2. After deployment, run HTTPS setup                                        â•‘"
          echo "â•‘     gh workflow run setup-https-plan-and-joy.yaml -f environment=${{ env.ENVIRONMENT }}"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
