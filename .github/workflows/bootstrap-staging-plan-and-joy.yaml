# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸš€ Bootstrap Staging Environment - Plan & Joy
# One-time setup for Staging environment with ArgoCD
# Generated by Opsera Code-to-Cloud v4.0
# Learning: SKILL-HUB-SPOKE-001 (Hub-Spoke Architecture)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
name: "ğŸš€ Bootstrap Staging - plan-and-joy"

on:
  workflow_dispatch:

env:
  APP_NAME: plan-and-joy
  TENANT: opsera
  AWS_REGION: us-west-2
  ENVIRONMENT: staging
  DOMAIN: agent.opsera.dev
  # SKILL-HUB-SPOKE-001: Define both clusters
  HUB_CLUSTER: argocd-usw2
  SPOKE_CLUSTER: opsera-usw2-np

jobs:
  bootstrap-staging:
    name: "ğŸš€ Bootstrap Staging Environment"
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get ECR URI
        id: ecr
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.TENANT }}/${{ env.APP_NAME }}"
          echo "uri=$ECR_URI" >> $GITHUB_OUTPUT
          echo "âœ… ECR URI: $ECR_URI"

      - name: Update Staging Kustomization with ECR URI
        run: |
          KUSTOMIZE_FILE=".opsera-${{ env.APP_NAME }}/k8s/overlays/${{ env.ENVIRONMENT }}/kustomization.yaml"
          ECR_URI="${{ steps.ecr.outputs.uri }}"
          
          sed -i "s|792373136340.dkr.ecr.us-west-2.amazonaws.com/opsera/plan-and-joy|$ECR_URI|" "$KUSTOMIZE_FILE" || true
          
          echo "âœ… Updated kustomization with ECR URI"
          cat "$KUSTOMIZE_FILE"

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # PHASE 1: Hub Cluster Operations (ArgoCD)
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: Connect to Hub Cluster
        run: |
          echo "ğŸ”— Connecting to Hub Cluster for ArgoCD operations..."
          aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }}

      - name: Verify Spoke Cluster Registration
        run: |
          echo "ğŸ” Verifying spoke cluster is registered with ArgoCD..."
          
          if kubectl get secret -n argocd -l argocd.argoproj.io/secret-type=cluster | grep -q "${{ env.SPOKE_CLUSTER }}"; then
            echo "âœ… Spoke cluster '${{ env.SPOKE_CLUSTER }}' is registered with ArgoCD"
          else
            echo "âš ï¸ Warning: Spoke cluster secret not found"
            kubectl get secrets -n argocd -l argocd.argoproj.io/secret-type=cluster \
              -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}'
          fi

      - name: Create ArgoCD Application
        run: |
          echo "ğŸ“ Creating ArgoCD Application for Staging..."
          kubectl apply -f .opsera-${{ env.APP_NAME }}/argocd/application-staging.yaml
          echo "âœ… ArgoCD application created for Staging"

      - name: Validate ArgoCD Sync Status
        run: |
          echo "â³ Waiting for ArgoCD to begin sync..."
          sleep 15
          
          MAX_ATTEMPTS=20
          for i in $(seq 1 $MAX_ATTEMPTS); do
            STATUS=$(kubectl get app ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} -n argocd \
              -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Pending")
            HEALTH=$(kubectl get app ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} -n argocd \
              -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Pending")
            
            echo "[$i/$MAX_ATTEMPTS] Sync: $STATUS | Health: $HEALTH"
            
            if [ "$STATUS" = "Unknown" ]; then
              echo "âš ï¸ Warning: Sync status 'Unknown' - possible cluster connectivity issue"
            fi
            
            if [ "$STATUS" = "Synced" ]; then
              echo "âœ… ArgoCD sync completed successfully"
              break
            fi
            
            sleep 10
          done

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # PHASE 2: Spoke Cluster Operations (DNS, Verification)
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: Connect to Spoke Cluster
        run: |
          echo "ğŸ”— Switching to Spoke Cluster for resource verification..."
          aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.AWS_REGION }}

      - name: Verify Resources on Spoke
        run: |
          echo "ğŸ” Checking resources on spoke cluster..."
          
          echo "ğŸ“¦ Namespace:"
          kubectl get namespace ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} || echo "âš ï¸ Namespace not yet created"
          
          echo "ğŸ“¦ All resources:"
          kubectl get all -n ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} 2>/dev/null || echo "âš ï¸ No resources yet"

      - name: Setup DNS Record
        run: |
          HOSTED_ZONE_ID=$(aws route53 list-hosted-zones-by-name --dns-name "${{ env.DOMAIN }}" --query "HostedZones[0].Id" --output text | cut -d'/' -f3)
          
          LB_HOSTNAME=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")
          
          if [ -n "$LB_HOSTNAME" ] && [ "$LB_HOSTNAME" != "null" ]; then
            SUBDOMAIN="${{ env.TENANT }}-${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}"
            
            echo "ğŸ“ Creating DNS record: $SUBDOMAIN.${{ env.DOMAIN }} â†’ $LB_HOSTNAME"
            
            aws route53 change-resource-record-sets --hosted-zone-id "$HOSTED_ZONE_ID" --change-batch '{
              "Changes": [{
                "Action": "UPSERT",
                "ResourceRecordSet": {
                  "Name": "'"$SUBDOMAIN.${{ env.DOMAIN }}"'",
                  "Type": "CNAME",
                  "TTL": 300,
                  "ResourceRecords": [{"Value": "'"$LB_HOSTNAME"'"}]
                }
              }]
            }'
            echo "âœ… DNS record created"
          else
            echo "âš ï¸ LoadBalancer not ready - run setup-https workflow after deployment"
          fi

      - name: Commit Kustomization Update
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git add .opsera-${{ env.APP_NAME }}/k8s/overlays/${{ env.ENVIRONMENT }}/kustomization.yaml
          
          if ! git diff --staged --quiet; then
            git commit -m "chore: configure staging environment [skip ci]"
            git push origin main
          fi

      - name: Display Bootstrap Summary
        run: |
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘  ğŸš€ STAGING ENVIRONMENT BOOTSTRAPPED                                             â•‘"
          echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
          echo "â•‘  App:          ${{ env.APP_NAME }}"
          echo "â•‘  Environment:  ${{ env.ENVIRONMENT }}"
          echo "â•‘  Namespace:    ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}"
          echo "â•‘  ECR URI:      ${{ steps.ecr.outputs.uri }}"
          echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
          echo "â•‘  ğŸ—ï¸ Architecture:                                                                â•‘"
          echo "â•‘  â”œâ”€ Hub Cluster:   ${{ env.HUB_CLUSTER }} (ArgoCD)"
          echo "â•‘  â””â”€ Spoke Cluster: ${{ env.SPOKE_CLUSTER }} (Workloads)"
          echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
          echo "â•‘  ğŸ“‹ Next Steps:                                                                  â•‘"
          echo "â•‘  1. Run Blue-Green Deploy workflow to deploy to staging                          â•‘"
          echo "â•‘     gh workflow run blue-green-deploy-plan-and-joy.yaml -f environment=staging   â•‘"
          echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
          echo "â•‘  ğŸŒ Staging URL (after deployment):                                              â•‘"
          echo "â•‘     https://${{ env.TENANT }}-${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}.${{ env.DOMAIN }}"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
