# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ”µğŸŸ¢ Blue-Green Deployment Pipeline - Plan & Joy
# Zero-downtime deployment with instant rollback capability
# Compatible with AWS EKS + NGINX Ingress Controller
# Generated by Opsera Code-to-Cloud v4.0
# Learning: SKILL-HUB-SPOKE-001 (Hub-Spoke Architecture)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
name: "ğŸ”µğŸŸ¢ Blue-Green Deploy - plan-and-joy"

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - prod
      skip_quality_gates:
        description: 'Skip quality gates (emergency only)'
        required: false
        default: false
        type: boolean
      preview_duration_minutes:
        description: 'Minutes to keep preview URL active before switch'
        required: false
        default: '5'
        type: string
      auto_switch:
        description: 'Auto-switch traffic after preview (false = manual approval)'
        required: false
        default: true
        type: boolean

env:
  APP_NAME: plan-and-joy
  TENANT: opsera
  AWS_REGION: us-west-2
  ENVIRONMENT: ${{ github.event.inputs.environment || 'staging' }}
  DOMAIN: agent.opsera.dev
  # SKILL-HUB-SPOKE-001: Define both clusters
  HUB_CLUSTER: argocd-usw2
  SPOKE_CLUSTER: opsera-usw2-np

concurrency:
  group: blue-green-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Job 1: Build Green Image
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  build-green:
    name: "ğŸ—ï¸ Build Green"
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.build.outputs.image_tag }}
      full_image: ${{ steps.build.outputs.full_image }}
      ecr_uri: ${{ steps.ecr.outputs.uri }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get ECR URI
        id: ecr
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.TENANT }}/${{ env.APP_NAME }}"
          echo "uri=$ECR_URI" >> $GITHUB_OUTPUT

      - name: Login to ECR
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
            docker login --username AWS --password-stdin ${{ steps.ecr.outputs.uri }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and Push Green Image
        id: build
        env:
          ECR_URI: ${{ steps.ecr.outputs.uri }}
          VITE_SUPABASE_URL: ${{ secrets.VITE_SUPABASE_URL }}
          VITE_SUPABASE_PUBLISHABLE_KEY: ${{ secrets.VITE_SUPABASE_PUBLISHABLE_KEY }}
        run: |
          IMAGE_TAG="green-${GITHUB_SHA:0:7}-$(date +%Y%m%d%H%M%S)"
          FULL_IMAGE="${ECR_URI}:${IMAGE_TAG}"

          echo "ğŸŸ¢ Building green image: $FULL_IMAGE"

          docker build \
            --build-arg VITE_SUPABASE_URL="${VITE_SUPABASE_URL}" \
            --build-arg VITE_SUPABASE_PUBLISHABLE_KEY="${VITE_SUPABASE_PUBLISHABLE_KEY}" \
            -t "$FULL_IMAGE" \
            -f .opsera-${{ env.APP_NAME }}/Dockerfile \
            .

          docker push "$FULL_IMAGE"

          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "full_image=$FULL_IMAGE" >> $GITHUB_OUTPUT
          echo "âœ… Green image pushed: $FULL_IMAGE"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Job 2: Quality Gates
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  quality-gates:
    name: "ğŸ”’ Quality Gates"
    runs-on: ubuntu-latest
    needs: build-green
    if: ${{ github.event.inputs.skip_quality_gates != 'true' }}
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
            docker login --username AWS --password-stdin ${{ needs.build-green.outputs.ecr_uri }}

      - name: Pull Green Image
        run: docker pull ${{ needs.build-green.outputs.full_image }}

      - name: Install Grype
        run: |
          curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin

      - name: Run Grype Scan
        run: |
          echo "ğŸ”’ Scanning green image for vulnerabilities..."
          grype ${{ needs.build-green.outputs.full_image }} --fail-on critical --output table
          echo "âœ… Security scan passed"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Job 3: Deploy Green (with Preview URL)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  deploy-green:
    name: "ğŸŸ¢ Deploy Green"
    runs-on: ubuntu-latest
    needs: [build-green, quality-gates]
    if: always() && needs.build-green.result == 'success' && (needs.quality-gates.result == 'success' || needs.quality-gates.result == 'skipped')
    outputs:
      green_healthy: ${{ steps.health.outputs.healthy }}
      preview_url: ${{ steps.preview.outputs.url }}
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # SKILL-HUB-SPOKE-001: Connect to SPOKE cluster for deployments
      - name: Connect to Spoke Cluster
        run: aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.AWS_REGION }}

      - name: Ensure Namespace Exists
        run: |
          NAMESPACE="${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}"
          kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy Green Version
        env:
          ECR_URI: ${{ needs.build-green.outputs.ecr_uri }}
          IMAGE_TAG: ${{ needs.build-green.outputs.image_tag }}
        run: |
          NAMESPACE="${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}"
          
          echo "ğŸŸ¢ Deploying green version..."
          
          # Create green deployment (separate from blue/stable)
          cat <<EOF | kubectl apply -f -
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: ${{ env.APP_NAME }}-green
            namespace: $NAMESPACE
            labels:
              app: ${{ env.APP_NAME }}
              version: green
              slot: green
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: ${{ env.APP_NAME }}
                slot: green
            template:
              metadata:
                labels:
                  app: ${{ env.APP_NAME }}
                  version: green
                  slot: green
              spec:
                containers:
                  - name: ${{ env.APP_NAME }}
                    image: ${ECR_URI}:${IMAGE_TAG}
                    ports:
                      - containerPort: 8080
                    resources:
                      requests:
                        cpu: "50m"
                        memory: "64Mi"
                      limits:
                        cpu: "500m"
                        memory: "512Mi"
                    readinessProbe:
                      httpGet:
                        path: /
                        port: 8080
                      initialDelaySeconds: 5
                      periodSeconds: 5
                    livenessProbe:
                      httpGet:
                        path: /
                        port: 8080
                      initialDelaySeconds: 15
                      periodSeconds: 10
                    startupProbe:
                      httpGet:
                        path: /
                        port: 8080
                      failureThreshold: 30
                      periodSeconds: 2
          EOF

          # Create green service
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: Service
          metadata:
            name: ${{ env.APP_NAME }}-green
            namespace: $NAMESPACE
            labels:
              app: ${{ env.APP_NAME }}
              slot: green
          spec:
            selector:
              app: ${{ env.APP_NAME }}
              slot: green
            ports:
              - port: 80
                targetPort: 8080
          EOF

          echo "âœ… Green deployment created"

      - name: Wait for Green Health
        id: health
        run: |
          NAMESPACE="${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}"
          echo "â³ Waiting for green pods to be healthy..."
          
          kubectl rollout status deployment/${{ env.APP_NAME }}-green -n $NAMESPACE --timeout=180s
          
          if [ $? -eq 0 ]; then
            echo "healthy=true" >> $GITHUB_OUTPUT
            echo "âœ… Green pods healthy"
          else
            echo "healthy=false" >> $GITHUB_OUTPUT
            echo "âŒ Green pods not healthy"
            exit 1
          fi

      - name: Create Preview Ingress
        id: preview
        run: |
          NAMESPACE="${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}"
          PREVIEW_HOST="${{ env.TENANT }}-${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}-preview.${{ env.DOMAIN }}"
          
          echo "ğŸ”— Creating preview ingress..."
          
          cat <<EOF | kubectl apply -f -
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: ${{ env.APP_NAME }}-preview
            namespace: $NAMESPACE
            labels:
              app: ${{ env.APP_NAME }}
              purpose: preview
            annotations:
              cert-manager.io/cluster-issuer: "letsencrypt-prod"
          spec:
            ingressClassName: nginx
            tls:
              - hosts:
                  - $PREVIEW_HOST
                secretName: ${{ env.APP_NAME }}-preview-tls
            rules:
              - host: $PREVIEW_HOST
                http:
                  paths:
                    - path: /
                      pathType: Prefix
                      backend:
                        service:
                          name: ${{ env.APP_NAME }}-green
                          port:
                            number: 80
          EOF

          echo "url=https://$PREVIEW_HOST" >> $GITHUB_OUTPUT
          echo "âœ… Preview URL: https://$PREVIEW_HOST"

      - name: Display Green Status
        run: |
          NAMESPACE="${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}"
          
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘  ğŸŸ¢ GREEN DEPLOYMENT READY                                   â•‘"
          echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
          echo "â•‘  Preview URL: ${{ steps.preview.outputs.url }}"
          echo "â•‘  Status: âœ… Healthy"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          
          echo ""
          echo "ğŸ“Š Deployments:"
          kubectl get deployments -n $NAMESPACE -o wide
          
          echo ""
          echo "ğŸ“Š Services:"
          kubectl get services -n $NAMESPACE
          
          echo ""
          echo "ğŸ“Š Ingresses:"
          kubectl get ingress -n $NAMESPACE

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Job 4: Preview Period
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  preview-period:
    name: "ğŸ‘€ Preview Period"
    runs-on: ubuntu-latest
    needs: [build-green, deploy-green]
    if: needs.deploy-green.outputs.green_healthy == 'true'
    outputs:
      approved: ${{ steps.check.outputs.approved }}
    steps:
      - name: Preview Information
        run: |
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘  ğŸ‘€ PREVIEW PERIOD ACTIVE                                    â•‘"
          echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
          echo "â•‘                                                              â•‘"
          echo "â•‘  ğŸŸ¢ Green (New):  ${{ needs.deploy-green.outputs.preview_url }}"
          echo "â•‘  ğŸ”µ Blue (Live):  https://${{ env.TENANT }}-${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}.${{ env.DOMAIN }}"
          echo "â•‘                                                              â•‘"
          echo "â•‘  Duration: ${{ github.event.inputs.preview_duration_minutes }} minutes"
          echo "â•‘  Auto-switch: ${{ github.event.inputs.auto_switch }}"
          echo "â•‘                                                              â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

      - name: Wait for Preview Period
        run: |
          WAIT_MINS=${{ github.event.inputs.preview_duration_minutes }}
          echo "ğŸ‘€ Preview period: $WAIT_MINS minutes"
          echo "   Test the green version at: ${{ needs.deploy-green.outputs.preview_url }}"
          sleep $(( WAIT_MINS * 60 ))

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Connect to Spoke Cluster
        run: aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.AWS_REGION }}

      - name: Verify Green Still Healthy
        id: check
        run: |
          NAMESPACE="${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}"
          
          READY=$(kubectl get deployment ${{ env.APP_NAME }}-green -n $NAMESPACE -o jsonpath='{.status.readyReplicas}' 2>/dev/null || echo "0")
          
          if [ "$READY" -ge 1 ]; then
            echo "approved=true" >> $GITHUB_OUTPUT
            echo "âœ… Green version stable during preview period"
          else
            echo "approved=false" >> $GITHUB_OUTPUT
            echo "âŒ Green version unstable"
            exit 1
          fi

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Job 5: Switch Traffic (Blue â†’ Green)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  switch-traffic:
    name: "ğŸ”„ Switch Traffic"
    runs-on: ubuntu-latest
    needs: [build-green, deploy-green, preview-period]
    if: needs.preview-period.outputs.approved == 'true'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}
          fetch-depth: 0

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Connect to Spoke Cluster
        run: aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.AWS_REGION }}

      - name: Switch Main Ingress to Green
        run: |
          NAMESPACE="${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}"
          HOST="${{ env.TENANT }}-${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}.${{ env.DOMAIN }}"
          
          echo "ğŸ”„ Switching production traffic to green..."
          
          # Update main ingress to point to green service
          cat <<EOF | kubectl apply -f -
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: ${{ env.APP_NAME }}
            namespace: $NAMESPACE
            labels:
              app: ${{ env.APP_NAME }}
              active-slot: green
            annotations:
              cert-manager.io/cluster-issuer: "letsencrypt-prod"
              nginx.ingress.kubernetes.io/ssl-redirect: "true"
          spec:
            ingressClassName: nginx
            tls:
              - hosts:
                  - $HOST
                secretName: ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}-tls
            rules:
              - host: $HOST
                http:
                  paths:
                    - path: /
                      pathType: Prefix
                      backend:
                        service:
                          name: ${{ env.APP_NAME }}-green
                          port:
                            number: 80
          EOF

          echo "âœ… Traffic switched to green"

      - name: Relabel Green as Blue (New Stable)
        env:
          ECR_URI: ${{ needs.build-green.outputs.ecr_uri }}
          IMAGE_TAG: ${{ needs.build-green.outputs.image_tag }}
        run: |
          NAMESPACE="${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}"
          
          echo "ğŸ”µ Promoting green to stable (blue)..."
          
          # Update or create the stable deployment with green's image
          if kubectl get deployment ${{ env.APP_NAME }} -n $NAMESPACE 2>/dev/null; then
            kubectl set image deployment/${{ env.APP_NAME }} \
              ${{ env.APP_NAME }}=${ECR_URI}:${IMAGE_TAG} \
              -n $NAMESPACE
          else
            cat <<EOF | kubectl apply -f -
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: ${{ env.APP_NAME }}
            namespace: $NAMESPACE
            labels:
              app: ${{ env.APP_NAME }}
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: ${{ env.APP_NAME }}
            template:
              metadata:
                labels:
                  app: ${{ env.APP_NAME }}
              spec:
                containers:
                  - name: ${{ env.APP_NAME }}
                    image: ${ECR_URI}:${IMAGE_TAG}
                    ports:
                      - containerPort: 8080
                    resources:
                      requests:
                        cpu: "50m"
                        memory: "64Mi"
                      limits:
                        cpu: "500m"
                        memory: "512Mi"
                    readinessProbe:
                      httpGet:
                        path: /
                        port: 8080
                      initialDelaySeconds: 5
                      periodSeconds: 5
          EOF
          fi

          # Ensure stable service exists
          if ! kubectl get service ${{ env.APP_NAME }} -n $NAMESPACE 2>/dev/null; then
            cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: Service
          metadata:
            name: ${{ env.APP_NAME }}
            namespace: $NAMESPACE
          spec:
            selector:
              app: ${{ env.APP_NAME }}
            ports:
              - port: 80
                targetPort: 8080
          EOF
          fi

          # Wait for stable deployment
          kubectl rollout status deployment/${{ env.APP_NAME }} -n $NAMESPACE --timeout=120s
          
          echo "âœ… Stable deployment updated"

      - name: Cleanup Green Resources
        run: |
          NAMESPACE="${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}"
          
          echo "ğŸ§¹ Cleaning up green resources..."
          
          # Delete green deployment and service (now redundant)
          kubectl delete deployment ${{ env.APP_NAME }}-green -n $NAMESPACE --ignore-not-found
          kubectl delete service ${{ env.APP_NAME }}-green -n $NAMESPACE --ignore-not-found
          kubectl delete ingress ${{ env.APP_NAME }}-preview -n $NAMESPACE --ignore-not-found
          
          echo "âœ… Green resources cleaned up"

      - name: Update Main Ingress to Stable Service
        run: |
          NAMESPACE="${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}"
          HOST="${{ env.TENANT }}-${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}.${{ env.DOMAIN }}"
          
          # Point main ingress back to stable service
          cat <<EOF | kubectl apply -f -
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: ${{ env.APP_NAME }}
            namespace: $NAMESPACE
            labels:
              app: ${{ env.APP_NAME }}
            annotations:
              cert-manager.io/cluster-issuer: "letsencrypt-prod"
              nginx.ingress.kubernetes.io/ssl-redirect: "true"
          spec:
            ingressClassName: nginx
            tls:
              - hosts:
                  - $HOST
                secretName: ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}-tls
            rules:
              - host: $HOST
                http:
                  paths:
                    - path: /
                      pathType: Prefix
                      backend:
                        service:
                          name: ${{ env.APP_NAME }}
                          port:
                            number: 80
          EOF

      - name: Update Kustomization
        run: |
          KUSTOMIZE_FILE=".opsera-${{ env.APP_NAME }}/k8s/overlays/${{ env.ENVIRONMENT }}/kustomization.yaml"
          ECR_URI="${{ needs.build-green.outputs.ecr_uri }}"
          IMAGE_TAG="${{ needs.build-green.outputs.image_tag }}"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git pull --rebase origin main

          sed -i "s|newName:.*|newName: $ECR_URI|" "$KUSTOMIZE_FILE"
          sed -i "s|newTag:.*|newTag: $IMAGE_TAG|" "$KUSTOMIZE_FILE"

          git add "$KUSTOMIZE_FILE"
          if ! git diff --staged --quiet; then
            git commit -m "chore: blue-green switch to $IMAGE_TAG in ${{ env.ENVIRONMENT }} [skip ci]"
            git push origin main
          fi

      - name: Display Success
        run: |
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘  ğŸ‰ BLUE-GREEN DEPLOYMENT COMPLETE                                               â•‘"
          echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
          echo "â•‘  App:         ${{ env.APP_NAME }}"
          echo "â•‘  Environment: ${{ env.ENVIRONMENT }}"
          echo "â•‘  Image:       ${{ needs.build-green.outputs.image_tag }}"
          echo "â•‘  Strategy:    Blue-Green (instant switch)"
          echo "â•‘  Status:      âœ… Successfully switched"
          echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
          echo "â•‘  ğŸŒ Live URL: https://${{ env.TENANT }}-${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}.${{ env.DOMAIN }}"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Job 6: Rollback (if any phase fails)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  rollback:
    name: "âª Rollback"
    runs-on: ubuntu-latest
    needs: [deploy-green, preview-period, switch-traffic]
    if: failure()
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Connect to Spoke Cluster
        run: aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.AWS_REGION }}

      - name: Rollback Green Deployment
        run: |
          NAMESPACE="${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}"
          
          echo "âª Rolling back - removing green resources..."
          
          # Delete green deployment and related resources
          kubectl delete deployment ${{ env.APP_NAME }}-green -n $NAMESPACE --ignore-not-found
          kubectl delete service ${{ env.APP_NAME }}-green -n $NAMESPACE --ignore-not-found
          kubectl delete ingress ${{ env.APP_NAME }}-preview -n $NAMESPACE --ignore-not-found
          
          echo "âœ… Green resources removed"
          echo "â„¹ï¸  Blue (stable) deployment remains unchanged"
          
          echo ""
          echo "ğŸ“Š Current state:"
          kubectl get deployments,services,ingress -n $NAMESPACE
