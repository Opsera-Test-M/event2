# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸš€ Bootstrap QA Environment - Plan & Joy
# One-time setup for QA environment with ArgoCD
# Generated by Opsera Code-to-Cloud v4.0
# Fixed: Hub-Spoke Architecture (SKILL-HUB-SPOKE-001)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
name: "ğŸš€ Bootstrap QA - plan-and-joy"

on:
  workflow_dispatch:

env:
  APP_NAME: plan-and-joy
  TENANT: opsera
  AWS_REGION: us-west-2
  ENVIRONMENT: qa
  DOMAIN: agent.opsera.dev
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # CRITICAL: Define BOTH clusters for hub-spoke architecture
  # HUB_CLUSTER: Where ArgoCD runs (management plane)
  # SPOKE_CLUSTER: Where applications run (workload plane)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  HUB_CLUSTER: argocd-usw2
  SPOKE_CLUSTER: opsera-usw2-np

jobs:
  bootstrap-qa:
    name: "ğŸš€ Bootstrap QA Environment"
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get ECR URI
        id: ecr
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.TENANT }}/${{ env.APP_NAME }}"
          echo "uri=$ECR_URI" >> $GITHUB_OUTPUT
          echo "âœ… ECR URI: $ECR_URI"

      - name: Update QA Kustomization with ECR URI
        run: |
          KUSTOMIZE_FILE=".opsera-${{ env.APP_NAME }}/k8s/overlays/${{ env.ENVIRONMENT }}/kustomization.yaml"
          ECR_URI="${{ steps.ecr.outputs.uri }}"
          
          sed -i "s|PLACEHOLDER_ECR_URI|$ECR_URI|" "$KUSTOMIZE_FILE" || true
          
          echo "âœ… Updated kustomization with ECR URI"
          cat "$KUSTOMIZE_FILE"

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # PHASE 1: Hub Cluster Operations (ArgoCD Management)
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: Connect to Hub Cluster
        run: |
          echo "ğŸ”— Connecting to Hub Cluster for ArgoCD operations..."
          aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }}

      - name: Verify Spoke Cluster Registration
        run: |
          echo "ğŸ” Verifying spoke cluster is registered with ArgoCD..."
          
          if kubectl get secret -n argocd -l argocd.argoproj.io/secret-type=cluster | grep -q "${{ env.SPOKE_CLUSTER }}"; then
            echo "âœ… Spoke cluster '${{ env.SPOKE_CLUSTER }}' is registered with ArgoCD"
          else
            echo "âš ï¸ Warning: Spoke cluster not found in ArgoCD secrets"
            echo "Available cluster secrets:"
            kubectl get secrets -n argocd -l argocd.argoproj.io/secret-type=cluster \
              -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}'
            echo ""
            echo "Proceeding anyway - cluster may be registered under different name"
          fi

      - name: Create ArgoCD Application
        run: |
          echo "ğŸ“ Creating ArgoCD Application for QA..."
          kubectl apply -f .opsera-${{ env.APP_NAME }}/argocd/application-qa.yaml
          echo "âœ… ArgoCD application created for QA"

      - name: Validate ArgoCD Sync Status
        run: |
          echo "â³ Waiting for ArgoCD to begin sync..."
          sleep 15
          
          MAX_ATTEMPTS=20
          for i in $(seq 1 $MAX_ATTEMPTS); do
            STATUS=$(kubectl get app ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} -n argocd \
              -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Pending")
            HEALTH=$(kubectl get app ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} -n argocd \
              -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Pending")
            
            echo "[$i/$MAX_ATTEMPTS] Sync: $STATUS | Health: $HEALTH"
            
            if [ "$STATUS" = "Unknown" ]; then
              echo ""
              echo "âš ï¸ Warning: Sync status 'Unknown' detected"
              echo "This may indicate cluster connectivity issues."
              echo "Checking ArgoCD application details..."
              kubectl get app ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} -n argocd -o yaml | grep -A10 "status:" || true
            fi
            
            if [ "$STATUS" = "Synced" ]; then
              echo "âœ… ArgoCD sync completed successfully"
              break
            fi
            
            if [ "$STATUS" = "OutOfSync" ] && [ "$HEALTH" != "Progressing" ]; then
              echo "ğŸ“‹ Checking sync details..."
              kubectl get app ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} -n argocd \
                -o jsonpath='{.status.conditions[*].message}' || true
            fi
            
            sleep 10
          done

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # PHASE 2: Spoke Cluster Operations (DNS, Verification)
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - name: Connect to Spoke Cluster
        run: |
          echo "ğŸ”— Switching to Spoke Cluster for resource verification..."
          aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.AWS_REGION }}

      - name: Verify Resources on Spoke
        run: |
          echo "ğŸ” Checking resources on spoke cluster..."
          
          echo ""
          echo "ğŸ“¦ Namespace:"
          kubectl get namespace ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} || echo "âš ï¸ Namespace not yet created (ArgoCD will create it)"
          
          echo ""
          echo "ğŸ“¦ All resources:"
          kubectl get all -n ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} 2>/dev/null || echo "âš ï¸ No resources yet"
          
          echo ""
          echo "ğŸ“¦ Ingress:"
          kubectl get ingress -n ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} 2>/dev/null || echo "âš ï¸ No ingress yet"

      - name: Setup DNS Record
        run: |
          HOSTED_ZONE_ID=$(aws route53 list-hosted-zones-by-name --dns-name "${{ env.DOMAIN }}" --query "HostedZones[0].Id" --output text | cut -d'/' -f3)
          
          # Get the LoadBalancer hostname from SPOKE cluster (where ingress-nginx runs)
          LB_HOSTNAME=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")
          
          if [ -n "$LB_HOSTNAME" ] && [ "$LB_HOSTNAME" != "null" ]; then
            SUBDOMAIN="${{ env.TENANT }}-${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}"
            
            echo "ğŸ“ Creating DNS record: $SUBDOMAIN.${{ env.DOMAIN }} â†’ $LB_HOSTNAME"
            
            aws route53 change-resource-record-sets --hosted-zone-id "$HOSTED_ZONE_ID" --change-batch '{
              "Changes": [{
                "Action": "UPSERT",
                "ResourceRecordSet": {
                  "Name": "'"$SUBDOMAIN.${{ env.DOMAIN }}"'",
                  "Type": "CNAME",
                  "TTL": 300,
                  "ResourceRecords": [{"Value": "'"$LB_HOSTNAME"'"}]
                }
              }]
            }'
            echo "âœ… DNS record created: $SUBDOMAIN.${{ env.DOMAIN }} â†’ $LB_HOSTNAME"
          else
            echo "âš ï¸ LoadBalancer not ready - DNS will be configured after first deployment"
            echo "Run 'setup-https' workflow after deployment to configure DNS"
          fi

      - name: Commit Kustomization Update
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git add .opsera-${{ env.APP_NAME }}/k8s/overlays/${{ env.ENVIRONMENT }}/kustomization.yaml
          
          if ! git diff --staged --quiet; then
            git commit -m "chore: configure QA environment with ECR URI [skip ci]"
            git push origin main
          fi

      - name: Display Bootstrap Summary
        run: |
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘  ğŸš€ QA ENVIRONMENT BOOTSTRAPPED                                                  â•‘"
          echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
          echo "â•‘  App:          ${{ env.APP_NAME }}"
          echo "â•‘  Environment:  ${{ env.ENVIRONMENT }}"
          echo "â•‘  Namespace:    ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}"
          echo "â•‘  ECR URI:      ${{ steps.ecr.outputs.uri }}"
          echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
          echo "â•‘  ğŸ—ï¸ Architecture:                                                                â•‘"
          echo "â•‘  â”œâ”€ Hub Cluster:   ${{ env.HUB_CLUSTER }} (ArgoCD)"
          echo "â•‘  â””â”€ Spoke Cluster: ${{ env.SPOKE_CLUSTER }} (Workloads)"
          echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
          echo "â•‘  ğŸ“‹ Next Steps:                                                                  â•‘"
          echo "â•‘  1. Run the Canary Deploy workflow to deploy to QA                               â•‘"
          echo "â•‘  2. Or run CI/CD workflow with environment=qa                                    â•‘"
          echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
          echo "â•‘  ğŸŒ QA URL (after deployment):                                                   â•‘"
          echo "â•‘     https://${{ env.TENANT }}-${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}.${{ env.DOMAIN }}"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
